# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T08:46:15+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path

from models import (
    DisruptionModes,
    DisruptionStatus,
    Expand,
    Expand1,
    Expand2,
    Expand3,
    Expand4,
    Expand5,
    Expand6,
    PlatformNumbers,
    RouteType,
    RouteTypes,
    RouteTypes1,
    RouteTypes2,
    RouteTypes3,
    TravelledRouteTypes,
    V3DeparturesResponse,
    V3DirectionsResponse,
    V3DisruptionModesResponse,
    V3DisruptionResponse,
    V3DisruptionsResponse,
    V3ErrorResponse,
    V3FareEstimateResponse,
    V3OutletGeolocationResponse,
    V3OutletResponse,
    V3RouteResponse,
    V3RouteTypesResponse,
    V3RunResponse,
    V3RunsResponse,
    V3SearchResult,
    V3StoppingPattern,
    V3StopResponse,
    V3StopsByDistanceResponse,
    V3StopsOnRouteResponse,
)

app = MCPProxy(
    contact={
        'name': 'Public Transport Victoria',
        'url': 'http://ptv.vic.gov.au/digital',
    },
    description="The PTV Timetable API provides direct access to Public Transport Victoriaâ€™s public transport timetable data.\r\n\r\nThe API returns scheduled timetable, route and stop data for all metropolitan and regional train, tram and bus services in Victoria, including Night Network(Night Train and Night Tram data are included in metropolitan train and tram services data, respectively, whereas Night Bus is a separate route type).\r\n\r\nThe API also returns real-time data for metropolitan train, tram and bus services (where this data is made available to PTV), as well as disruption information, stop facility information, and access to myki ticket outlet data.\r\n\r\nThis Swagger is for Version 3 of the PTV Timetable API. By using this documentation you agree to comply with the licence and terms of service.\r\n\r\nTrain timetable data is updated daily, while the remaining data is updated weekly, taking into account any planned timetable changes (for example, due to holidays or planned disruptions). The PTV timetable API is the same API used by PTV for its apps. To access the most up to date data PTV has (including real-time data) you must use the API dynamically.\r\n\r\nYou can access the PTV Timetable API through a HTTP or HTTPS interface, as follows:\r\n\r\n    base URL / version number / API name / query string\r\nThe base URL is either:\r\n  *  http://timetableapi.ptv.vic.gov.au\r\nor\r\n  *  https://timetableapi.ptv.vic.gov.au\r\n\r\nThe Swagger JSON file is available at http://timetableapi.ptv.vic.gov.au/swagger/docs/v3\r\n\r\nFrequently asked questions are available on the PTV website at http://ptv.vic.gov.au/apifaq\r\n\r\nLinks to the following information are also provided on the PTV website at http://ptv.vic.gov.au/ptv-timetable-api/\r\n* How to register for an API key and calculate a signature\r\n* PTV Timetable API V2 to V3 Migration Guide\r\n* Documentation for Version 2 of the PTV Timetable API\r\n* PTV Timetable API Data Quality Statement\r\n\r\nAll information about how to use the API is in this documentation. PTV cannot provide technical support for the API.\r\n\r\nCredits: This page has been based on Steve Bennett's http://opentransportdata.org/, used with permission.\r\n",
    license={
        'name': 'Creative Commons Attribution 4.0 International',
        'url': 'https://creativecommons.org/licenses/by/4.0/',
    },
    title='PTV Timetable API - Version 3',
    version='v3',
    servers=[
        {'url': 'http://timetableapi.ptv.vic.gov.au'},
        {'url': 'https://timetableapi.ptv.vic.gov.au'},
    ],
)


@app.get(
    '/v3/departures/route_type/{route_type}/stop/{stop_id}',
    tags=[
        'departure_queries',
        'route_direction_details',
        'route_information_retrieval',
        'service_run_overview',
    ],
)
def departures__get_for_stop(
    route_type: RouteType,
    stop_id: int = ...,
    platform_numbers: Optional[PlatformNumbers] = None,
    direction_id: Optional[int] = None,
    gtfs: Optional[bool] = None,
    date_utc: Optional[datetime] = None,
    max_results: Optional[int] = None,
    include_cancelled: Optional[bool] = None,
    look_backwards: Optional[bool] = None,
    expand: Optional[Expand] = None,
    include_geopath: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View departures for all routes from a stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/departures/route_type/{route_type}/stop/{stop_id}/route/{route_id}',
    tags=['departure_queries', 'route_information_retrieval', 'service_run_overview'],
)
def departures__get_for_stop_and_route(
    route_type: RouteType,
    stop_id: int = ...,
    route_id: str = ...,
    direction_id: Optional[int] = None,
    gtfs: Optional[bool] = None,
    date_utc: Optional[datetime] = None,
    max_results: Optional[int] = None,
    include_cancelled: Optional[bool] = None,
    look_backwards: Optional[bool] = None,
    expand: Optional[Expand1] = None,
    include_geopath: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View departures for a specific route from a stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/directions/route/{route_id}',
    tags=['route_direction_details', 'route_information_retrieval'],
)
def directions__for_route(
    route_id: int,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View directions that a route travels in
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/directions/{direction_id}',
    tags=['route_direction_details', 'route_information_retrieval'],
)
def directions__for_direction(
    direction_id: int,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all routes for a direction of travel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/directions/{direction_id}/route_type/{route_type}',
    tags=[
        'departure_queries',
        'route_direction_details',
        'route_information_retrieval',
    ],
)
def directions__for_direction_and_type(
    direction_id: int,
    route_type: RouteType = ...,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all routes of a particular type for a direction of travel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/disruptions', tags=['transport_disruption_updates'])
def disruptions__get_all_disruptions(
    route_types: Optional[RouteTypes] = None,
    disruption_modes: Optional[DisruptionModes] = None,
    disruption_status: Optional[DisruptionStatus] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all disruptions for all route types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/disruptions/modes', tags=['transport_disruption_updates'])
def disruptions__get_disruption_modes(
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    Get all disruption modes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/disruptions/route/{route_id}', tags=['transport_disruption_updates'])
def disruptions__get_disruptions_by_route(
    route_id: int,
    disruption_status: Optional[DisruptionStatus] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all disruptions for a particular route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/disruptions/route/{route_id}/stop/{stop_id}',
    tags=['transport_disruption_updates'],
)
def disruptions__get_disruptions_by_route_and_stop(
    route_id: int,
    stop_id: int = ...,
    disruption_status: Optional[DisruptionStatus] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all disruptions for a particular route and stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/disruptions/stop/{stop_id}',
    tags=['transport_disruption_updates', 'stop_details_query'],
)
def disruptions__get_disruptions_by_stop(
    stop_id: int,
    disruption_status: Optional[DisruptionStatus] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all disruptions for a particular stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/disruptions/{disruption_id}', tags=['transport_disruption_updates'])
def disruptions__get_disruption_by_id(
    disruption_id: int,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View a specific disruption
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/fare_estimate/min_zone/{minZone}/max_zone/{maxZone}',
    tags=['fare_calculation_services'],
)
def fare_estimate__get_fare_estimate_by_zone(
    min_zone: int = Path(..., alias='minZone'),
    max_zone: int = Path(..., alias='maxZone'),
    journey_touch_on_utc: Optional[datetime] = None,
    journey_touch_off_utc: Optional[datetime] = None,
    is_journey_in_free_tram_zone: Optional[bool] = None,
    travelled_route_types: Optional[TravelledRouteTypes] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    Estimate a fare by zone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/outlets', tags=['ticket_outlet_search'])
def outlets__get_all_outlets(
    max_results: Optional[int] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    List all ticket outlets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/outlets/location/{latitude},{longitude}',
    tags=['ticket_outlet_search', 'geographical_search_tools'],
)
def outlets__get_outlets_by_geolocation(
    latitude: float,
    longitude: float = ...,
    max_distance: Optional[float] = None,
    max_results: Optional[int] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    List ticket outlets near a specific location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/pattern/run/{run_ref}/route_type/{route_type}',
    tags=[
        'service_pattern_viewing',
        'route_information_retrieval',
        'service_run_overview',
    ],
)
def patterns__get_pattern_by_run(
    run_ref: str,
    route_type: RouteType = ...,
    expand: Expand2 = ...,
    stop_id: Optional[int] = None,
    date_utc: Optional[datetime] = None,
    include_skipped_stops: Optional[bool] = None,
    include_geopath: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View the stopping pattern for a specific trip/service run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/route_types', tags=['route_information_retrieval'])
def route_types__get_route_types(
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all route types and their names
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v3/routes', tags=['route_information_retrieval', 'service_run_overview'])
def routes__one_or_more_routes(
    route_types: Optional[RouteTypes1] = None,
    route_name: Optional[str] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View route names and numbers for all routes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/routes/{route_id}',
    tags=['route_information_retrieval', 'route_direction_details'],
)
def routes__route_from_id(
    route_id: int,
    include_geopath: Optional[bool] = None,
    geopath_utc: Optional[datetime] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View route name and number for specific route ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/runs/route/{route_id}',
    tags=['route_information_retrieval', 'service_run_overview'],
)
def runs__for_route(
    route_id: int,
    expand: Optional[Expand3] = None,
    date_utc: Optional[datetime] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all trip/service runs for a specific route ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/runs/route/{route_id}/route_type/{route_type}',
    tags=['service_run_overview', 'route_information_retrieval', 'departure_queries'],
)
def runs__for_route_and_route_type(
    route_id: int,
    route_type: RouteType = ...,
    expand: Expand4 = ...,
    date_utc: Optional[datetime] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all trip/service runs for a specific route ID and route type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/runs/{run_ref}',
    tags=[
        'service_run_overview',
        'route_information_retrieval',
        'service_pattern_viewing',
    ],
)
def runs__for_run(
    run_ref: str,
    expand: Expand5 = ...,
    date_utc: Optional[datetime] = None,
    include_geopath: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all trip/service runs for a specific run_ref
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/runs/{run_ref}/route_type/{route_type}',
    tags=[
        'service_run_overview',
        'route_information_retrieval',
        'service_pattern_viewing',
    ],
)
def runs__for_run_and_route_type(
    run_ref: str,
    route_type: RouteType = ...,
    expand: Expand6 = ...,
    date_utc: Optional[datetime] = None,
    include_geopath: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View the trip/service run for a specific run_ref and route type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/search/{search_term}',
    tags=[
        'ticket_outlet_search',
        'geographical_search_tools',
        'route_information_retrieval',
        'stop_details_query',
    ],
)
def search__search(
    search_term: str,
    route_types: Optional[RouteTypes2] = None,
    latitude: Optional[float] = None,
    longitude: Optional[float] = None,
    max_distance: Optional[float] = None,
    include_addresses: Optional[bool] = None,
    include_outlets: Optional[bool] = None,
    match_stop_by_suburb: Optional[bool] = None,
    match_route_by_suburb: Optional[bool] = None,
    match_stop_by_gtfs_stop_id: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View stops, routes and myki ticket outlets that match the search term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/stops/location/{latitude},{longitude}',
    tags=['geographical_search_tools', 'stop_details_query'],
)
def stops__stops_by_geolocation(
    latitude: float,
    longitude: float = ...,
    route_types: Optional[RouteTypes3] = None,
    max_results: Optional[int] = None,
    max_distance: Optional[float] = None,
    stop_disruptions: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all stops near a specific location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/stops/route/{route_id}/route_type/{route_type}',
    tags=['route_information_retrieval', 'stop_details_query'],
)
def stops__stops_for_route(
    route_id: int,
    route_type: RouteType = ...,
    direction_id: Optional[int] = None,
    stop_disruptions: Optional[bool] = None,
    include_geopath: Optional[bool] = None,
    geopath_utc: Optional[datetime] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View all stops on a specific route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/stops/{stop_id}/route_type/{route_type}',
    tags=['stop_details_query', 'transport_disruption_updates'],
)
def stops__stop_details(
    stop_id: int,
    route_type: RouteType = ...,
    stop_location: Optional[bool] = None,
    stop_amenities: Optional[bool] = None,
    stop_accessibility: Optional[bool] = None,
    stop_contact: Optional[bool] = None,
    stop_ticket: Optional[bool] = None,
    gtfs: Optional[bool] = None,
    stop_staffing: Optional[bool] = None,
    stop_disruptions: Optional[bool] = None,
    token: Optional[str] = None,
    devid: Optional[str] = None,
    signature: Optional[str] = None,
):
    """
    View facilities at a specific stop (Metro and V/Line stations only)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
